import { sqliteTable, text, integer, real } from "drizzle-orm/sqlite-core";
import { sql } from "drizzle-orm";

export const tracks = sqliteTable("tracks", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  title: text("title").notNull(),
  artist: text("artist").notNull().default("Unknown Artist"),
  album: text("album").notNull().default("Unknown Album"),
  albumArtist: text("album_artist"),
  genre: text("genre"),
  year: integer("year"),
  trackNumber: integer("track_number"),
  discNumber: integer("disc_number"),
  duration: real("duration").notNull().default(0),
  filePath: text("file_path").notNull().unique(),
  fileSize: integer("file_size"),
  format: text("format"),
  bitrate: integer("bitrate"),
  sampleRate: integer("sample_rate"),
  coverPath: text("cover_path"),
  source: text("source").notNull().default("local"),
  sourceId: text("source_id"),
  addedAt: text("added_at").default(sql`(datetime('now'))`),
  lastPlayedAt: text("last_played_at"),
  playCount: integer("play_count").default(0),
});

export const playlists = sqliteTable("playlists", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  name: text("name").notNull(),
  description: text("description"),
  coverPath: text("cover_path"),
  isAutoGenerated: integer("is_auto_generated", { mode: "boolean" }).default(false),
  createdAt: text("created_at").default(sql`(datetime('now'))`),
  updatedAt: text("updated_at").default(sql`(datetime('now'))`),
});

export const playlistTracks = sqliteTable("playlist_tracks", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  playlistId: integer("playlist_id")
    .notNull()
    .references(() => playlists.id, { onDelete: "cascade" }),
  trackId: integer("track_id")
    .notNull()
    .references(() => tracks.id, { onDelete: "cascade" }),
  position: integer("position").notNull(),
  addedAt: text("added_at").default(sql`(datetime('now'))`),
});

export const listeningHistory = sqliteTable("listening_history", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  trackId: integer("track_id").references(() => tracks.id, { onDelete: "set null" }),
  trackTitle: text("track_title").notNull(),
  trackArtist: text("track_artist").notNull(),
  source: text("source").notNull().default("local"),
  playedAt: text("played_at").default(sql`(datetime('now'))`),
  duration: real("duration"),
  listenedDuration: real("listened_duration"),
  outputTarget: text("output_target").default("browser"),
});

export const tasteFeedback = sqliteTable("taste_feedback", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  sessionId: integer("session_id")
    .notNull()
    .references(() => discoverySessions.id, { onDelete: "cascade" }),
  trackId: integer("track_id").references(() => tracks.id, { onDelete: "set null" }),
  trackTitle: text("track_title").notNull(),
  trackArtist: text("track_artist").notNull(),
  rating: text("rating").notNull(), // "bad" | "ok" | "amazing"
  createdAt: text("created_at").default(sql`(datetime('now'))`),
});

export const discoverySessions = sqliteTable("discovery_sessions", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  genres: text("genres"), // JSON array
  moodLevel: integer("mood_level"),
  tempoLevel: integer("tempo_level"),
  eraPreference: text("era_preference"),
  status: text("status").notNull().default("active"), // "active" | "completed"
  createdAt: text("created_at").default(sql`(datetime('now'))`),
  completedAt: text("completed_at"),
});

export const tasteProfile = sqliteTable("taste_profile", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  profileText: text("profile_text").notNull(),
  genreDistribution: text("genre_distribution"), // JSON
  topArtists: text("top_artists"), // JSON array
  moodPreferences: text("mood_preferences"), // JSON
  generatedAt: text("generated_at").default(sql`(datetime('now'))`),
  feedbackCount: integer("feedback_count").default(0),
});

export const albumRules = sqliteTable("album_rules", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  pattern: text("pattern").notNull(),
  targetAlbum: text("target_album").notNull(),
  targetAlbumArtist: text("target_album_artist"),
  createdAt: text("created_at").default(sql`(datetime('now'))`),
});

export const settings = sqliteTable("settings", {
  key: text("key").primaryKey(),
  value: text("value").notNull(),
  updatedAt: text("updated_at").default(sql`(datetime('now'))`),
});

export const trackLyrics = sqliteTable("track_lyrics", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  trackId: integer("track_id")
    .notNull()
    .references(() => tracks.id, { onDelete: "cascade" })
    .unique(),
  content: text("content").notNull(),
  format: text("format").notNull(), // "lrc" | "plain"
  source: text("source").notNull(), // "embedded" | "lrclib" | "manual"
  fetchedAt: text("fetched_at").default(sql`(datetime('now'))`),
});

export type AlbumRule = typeof albumRules.$inferSelect;
export type NewAlbumRule = typeof albumRules.$inferInsert;
export type Track = typeof tracks.$inferSelect;
export type NewTrack = typeof tracks.$inferInsert;
export type Playlist = typeof playlists.$inferSelect;
export type NewPlaylist = typeof playlists.$inferInsert;
export type ListeningHistoryEntry = typeof listeningHistory.$inferSelect;
export type TasteFeedbackEntry = typeof tasteFeedback.$inferSelect;
export type DiscoverySession = typeof discoverySessions.$inferSelect;
export type TasteProfile = typeof tasteProfile.$inferSelect;
export type TrackLyrics = typeof trackLyrics.$inferSelect;
export type NewTrackLyrics = typeof trackLyrics.$inferInsert;

// ---------- Podcast tables ----------

export const podcasts = sqliteTable("podcasts", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  title: text("title").notNull(),
  author: text("author"),
  description: text("description"),
  feedUrl: text("feed_url").notNull().unique(),
  coverUrl: text("cover_url"),
  coverPath: text("cover_path"),
  lastFetchedAt: text("last_fetched_at"),
  addedAt: text("added_at").default(sql`(datetime('now'))`),
});

export const podcastEpisodes = sqliteTable("podcast_episodes", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  podcastId: integer("podcast_id")
    .notNull()
    .references(() => podcasts.id, { onDelete: "cascade" }),
  guid: text("guid"),
  title: text("title").notNull(),
  description: text("description"),
  pubDate: text("pub_date"),
  duration: real("duration"),
  audioUrl: text("audio_url").notNull(),
  localPath: text("local_path"),
  coverUrl: text("cover_url"),
  coverPath: text("cover_path"),
  fileSize: integer("file_size"),
  listenedAt: text("listened_at"),
  playPosition: real("play_position").default(0),
  isDownloaded: integer("is_downloaded", { mode: "boolean" }).default(false),
  addedAt: text("added_at").default(sql`(datetime('now'))`),
});

export const episodeInsights = sqliteTable("episode_insights", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  episodeId: integer("episode_id")
    .notNull()
    .references(() => podcastEpisodes.id, { onDelete: "cascade" }),
  type: text("type").notNull(), // "summary" | "wisdom" | "transcript"
  content: text("content").notNull(),
  generatedAt: text("generated_at").default(sql`(datetime('now'))`),
});

export type Podcast = typeof podcasts.$inferSelect;
export type NewPodcast = typeof podcasts.$inferInsert;
export type PodcastEpisode = typeof podcastEpisodes.$inferSelect;
export type NewPodcastEpisode = typeof podcastEpisodes.$inferInsert;
export type EpisodeInsight = typeof episodeInsights.$inferSelect;
