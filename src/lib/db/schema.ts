import { sqliteTable, text, integer, real } from "drizzle-orm/sqlite-core";
import { sql } from "drizzle-orm";

export const tracks = sqliteTable("tracks", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  title: text("title").notNull(),
  artist: text("artist").notNull().default("Unknown Artist"),
  album: text("album").notNull().default("Unknown Album"),
  albumArtist: text("album_artist"),
  genre: text("genre"),
  year: integer("year"),
  trackNumber: integer("track_number"),
  discNumber: integer("disc_number"),
  duration: real("duration").notNull().default(0),
  filePath: text("file_path").notNull().unique(),
  fileSize: integer("file_size"),
  format: text("format"),
  bitrate: integer("bitrate"),
  sampleRate: integer("sample_rate"),
  coverPath: text("cover_path"),
  isrc: text("isrc"),
  source: text("source").notNull().default("local"),
  sourceId: text("source_id"),
  addedAt: text("added_at").default(sql`(datetime('now'))`),
  lastPlayedAt: text("last_played_at"),
  playCount: integer("play_count").default(0),
});

export const playlists = sqliteTable("playlists", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  name: text("name").notNull(),
  description: text("description"),
  coverPath: text("cover_path"),
  isAutoGenerated: integer("is_auto_generated", { mode: "boolean" }).default(false),
  createdAt: text("created_at").default(sql`(datetime('now'))`),
  updatedAt: text("updated_at").default(sql`(datetime('now'))`),
});

export const playlistTracks = sqliteTable("playlist_tracks", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  playlistId: integer("playlist_id")
    .notNull()
    .references(() => playlists.id, { onDelete: "cascade" }),
  trackId: integer("track_id")
    .notNull()
    .references(() => tracks.id, { onDelete: "cascade" }),
  position: integer("position").notNull(),
  addedAt: text("added_at").default(sql`(datetime('now'))`),
});

export const listeningHistory = sqliteTable("listening_history", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  trackId: integer("track_id").references(() => tracks.id, { onDelete: "set null" }),
  trackTitle: text("track_title").notNull(),
  trackArtist: text("track_artist").notNull(),
  source: text("source").notNull().default("local"),
  playedAt: text("played_at").default(sql`(datetime('now'))`),
  duration: real("duration"),
  listenedDuration: real("listened_duration"),
  outputTarget: text("output_target").default("browser"),
});

export const tasteFeedback = sqliteTable("taste_feedback", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  sessionId: integer("session_id")
    .notNull()
    .references(() => discoverySessions.id, { onDelete: "cascade" }),
  trackId: integer("track_id").references(() => tracks.id, { onDelete: "set null" }),
  trackTitle: text("track_title").notNull(),
  trackArtist: text("track_artist").notNull(),
  rating: text("rating").notNull(), // "bad" | "ok" | "amazing"
  createdAt: text("created_at").default(sql`(datetime('now'))`),
});

export const discoverySessions = sqliteTable("discovery_sessions", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  genres: text("genres"), // JSON array
  moodLevel: integer("mood_level"),
  tempoLevel: integer("tempo_level"),
  eraPreference: text("era_preference"),
  status: text("status").notNull().default("active"), // "active" | "completed"
  createdAt: text("created_at").default(sql`(datetime('now'))`),
  completedAt: text("completed_at"),
});

export const tasteProfile = sqliteTable("taste_profile", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  profileText: text("profile_text").notNull(),
  genreDistribution: text("genre_distribution"), // JSON
  topArtists: text("top_artists"), // JSON array
  moodPreferences: text("mood_preferences"), // JSON
  generatedAt: text("generated_at").default(sql`(datetime('now'))`),
  feedbackCount: integer("feedback_count").default(0),
});

export const albumRules = sqliteTable("album_rules", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  pattern: text("pattern").notNull(),
  targetAlbum: text("target_album").notNull(),
  targetAlbumArtist: text("target_album_artist"),
  createdAt: text("created_at").default(sql`(datetime('now'))`),
});

export const settings = sqliteTable("settings", {
  key: text("key").primaryKey(),
  value: text("value").notNull(),
  updatedAt: text("updated_at").default(sql`(datetime('now'))`),
});

export const trackRatings = sqliteTable("track_ratings", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  trackId: integer("track_id")
    .notNull()
    .references(() => tracks.id, { onDelete: "cascade" })
    .unique(),
  rating: integer("rating").notNull(),
  ratedAt: text("rated_at").default(sql`(datetime('now'))`),
});

export const trackLyrics = sqliteTable("track_lyrics", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  trackId: integer("track_id")
    .notNull()
    .references(() => tracks.id, { onDelete: "cascade" })
    .unique(),
  content: text("content").notNull(),
  format: text("format").notNull(), // "lrc" | "plain"
  source: text("source").notNull(), // "embedded" | "lrclib" | "manual"
  fetchedAt: text("fetched_at").default(sql`(datetime('now'))`),
});

export type AlbumRule = typeof albumRules.$inferSelect;
export type NewAlbumRule = typeof albumRules.$inferInsert;
export type Track = typeof tracks.$inferSelect;
export type NewTrack = typeof tracks.$inferInsert;
export type Playlist = typeof playlists.$inferSelect;
export type NewPlaylist = typeof playlists.$inferInsert;
export type ListeningHistoryEntry = typeof listeningHistory.$inferSelect;
export type TasteFeedbackEntry = typeof tasteFeedback.$inferSelect;
export type DiscoverySession = typeof discoverySessions.$inferSelect;
export type TasteProfile = typeof tasteProfile.$inferSelect;
export type TrackRating = typeof trackRatings.$inferSelect;
export type NewTrackRating = typeof trackRatings.$inferInsert;
export type TrackLyrics = typeof trackLyrics.$inferSelect;
export type NewTrackLyrics = typeof trackLyrics.$inferInsert;

// ---------- Podcast tables ----------

export const podcasts = sqliteTable("podcasts", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  title: text("title").notNull(),
  author: text("author"),
  description: text("description"),
  feedUrl: text("feed_url").notNull().unique(),
  coverUrl: text("cover_url"),
  coverPath: text("cover_path"),
  lastFetchedAt: text("last_fetched_at"),
  addedAt: text("added_at").default(sql`(datetime('now'))`),
});

export const podcastEpisodes = sqliteTable("podcast_episodes", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  podcastId: integer("podcast_id")
    .notNull()
    .references(() => podcasts.id, { onDelete: "cascade" }),
  guid: text("guid"),
  title: text("title").notNull(),
  description: text("description"),
  pubDate: text("pub_date"),
  duration: real("duration"),
  audioUrl: text("audio_url").notNull(),
  localPath: text("local_path"),
  coverUrl: text("cover_url"),
  coverPath: text("cover_path"),
  fileSize: integer("file_size"),
  listenedAt: text("listened_at"),
  playPosition: real("play_position").default(0),
  isDownloaded: integer("is_downloaded", { mode: "boolean" }).default(false),
  addedAt: text("added_at").default(sql`(datetime('now'))`),
});

export const episodeInsights = sqliteTable("episode_insights", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  episodeId: integer("episode_id")
    .notNull()
    .references(() => podcastEpisodes.id, { onDelete: "cascade" }),
  type: text("type").notNull(), // "summary" | "wisdom" | "transcript"
  content: text("content").notNull(),
  generatedAt: text("generated_at").default(sql`(datetime('now'))`),
});

export type Podcast = typeof podcasts.$inferSelect;
export type NewPodcast = typeof podcasts.$inferInsert;
export type PodcastEpisode = typeof podcastEpisodes.$inferSelect;
export type NewPodcastEpisode = typeof podcastEpisodes.$inferInsert;
export type EpisodeInsight = typeof episodeInsights.$inferSelect;

// ---------- DJ Session tables ----------
// [VynlDJ] — extractable: DJ session persistence

export const djSessions = sqliteTable("dj_sessions", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  audience: text("audience"), // JSON array of age groups
  vibe: text("vibe").notNull(), // "chill" | "mixed" | "dance" | "high_energy"
  durationMinutes: integer("duration_minutes"),
  occasion: text("occasion"),
  specialRequests: text("special_requests"),
  djNotes: text("dj_notes"),
  trackCount: integer("track_count").default(0),
  status: text("status").notNull().default("generating"), // "generating" | "ready" | "playing" | "completed"
  createdAt: text("created_at").default(sql`(datetime('now'))`),
});

export const djSessionTracks = sqliteTable("dj_session_tracks", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  sessionId: integer("session_id")
    .notNull()
    .references(() => djSessions.id, { onDelete: "cascade" }),
  trackId: integer("track_id")
    .notNull()
    .references(() => tracks.id, { onDelete: "cascade" }),
  position: integer("position").notNull(),
  djNote: text("dj_note"),
  played: integer("played").default(0),
  skipped: integer("skipped").default(0),
});

export type DjSession = typeof djSessions.$inferSelect;
export type NewDjSession = typeof djSessions.$inferInsert;
export type DjSessionTrack = typeof djSessionTracks.$inferSelect;
export type NewDjSessionTrack = typeof djSessionTracks.$inferInsert;

// ---------- Track Audio Features ----------
// [VynlDJ] — extractable: LLM/audio-analyzed track features for DJ mixing

export const trackAudioFeatures = sqliteTable("track_audio_features", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  trackId: integer("track_id")
    .notNull()
    .references(() => tracks.id, { onDelete: "cascade" })
    .unique(),
  bpm: real("bpm"),
  energy: real("energy"),                // 0.0-1.0 (calm → intense)
  danceability: real("danceability"),    // 0.0-1.0
  key: text("key"),                      // "C major", "A minor"
  camelot: text("camelot"),              // "8B", "5A" for harmonic mixing
  genreRefined: text("genre_refined"),   // LLM-refined genre
  styleTags: text("style_tags"),         // JSON array: ["groovy","upbeat"]
  analysisMethod: text("analysis_method").notNull().default("llm"), // "llm" | "audio" | "manual"
  confidence: real("confidence").default(0.5),
  analyzedAt: text("analyzed_at").default(sql`(datetime('now'))`),
});

export type TrackAudioFeatures = typeof trackAudioFeatures.$inferSelect;
export type NewTrackAudioFeatures = typeof trackAudioFeatures.$inferInsert;

// ---------- Spotify Integration tables ----------

export const spotifyAuth = sqliteTable("spotify_auth", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  accessToken: text("access_token").notNull(),
  refreshToken: text("refresh_token").notNull(),
  expiresAt: text("expires_at").notNull(),
  spotifyUserId: text("spotify_user_id").notNull(),
  spotifyDisplayName: text("spotify_display_name"),
});

export const spotifySnapshots = sqliteTable("spotify_snapshots", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  status: text("status").notNull().default("running"), // "running" | "complete" | "error" | "cancelled"
  totalPlaylists: integer("total_playlists").default(0),
  totalTracks: integer("total_tracks").default(0),
  totalLikedSongs: integer("total_liked_songs").default(0),
  matchedTracks: integer("matched_tracks").default(0),
  unmatchedTracks: integer("unmatched_tracks").default(0),
  startedAt: text("started_at").default(sql`(datetime('now'))`),
  completedAt: text("completed_at"),
});

export const spotifyPlaylists = sqliteTable("spotify_playlists", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  snapshotId: integer("snapshot_id")
    .notNull()
    .references(() => spotifySnapshots.id, { onDelete: "cascade" }),
  spotifyId: text("spotify_id").notNull(),
  name: text("name").notNull(),
  description: text("description"),
  imageUrl: text("image_url"),
  trackCount: integer("track_count").default(0),
  vynlPlaylistId: integer("vynl_playlist_id").references(() => playlists.id, { onDelete: "set null" }),
});

export const spotifyTracks = sqliteTable("spotify_tracks", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  snapshotId: integer("snapshot_id")
    .notNull()
    .references(() => spotifySnapshots.id, { onDelete: "cascade" }),
  spotifyId: text("spotify_id").notNull(),
  spotifyUri: text("spotify_uri"),
  title: text("title").notNull(),
  artist: text("artist").notNull(),
  album: text("album"),
  isrc: text("isrc"),
  durationMs: integer("duration_ms"),
  coverUrl: text("cover_url"),
  previewUrl: text("preview_url"),
  isLikedSong: integer("is_liked_song", { mode: "boolean" }).default(false),
  bpm: real("bpm"),
  energy: real("energy"),
  danceability: real("danceability"),
  valence: real("valence"),
  popularity: integer("popularity"), // 0-100 Spotify global popularity
  audioKey: integer("audio_key"),
  audioMode: integer("audio_mode"),
  localTrackId: integer("local_track_id").references(() => tracks.id, { onDelete: "set null" }),
  matchMethod: text("match_method"), // "isrc" | "fuzzy" | null
  matchConfidence: real("match_confidence"),
});

export const spotifyPlaylistTracks = sqliteTable("spotify_playlist_tracks", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  spotifyPlaylistId: integer("spotify_playlist_id")
    .notNull()
    .references(() => spotifyPlaylists.id, { onDelete: "cascade" }),
  spotifyTrackId: integer("spotify_track_id")
    .notNull()
    .references(() => spotifyTracks.id, { onDelete: "cascade" }),
  position: integer("position").notNull(),
});

export const wishList = sqliteTable("wish_list", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  type: text("type").notNull().default("spotify_missing"), // "spotify_missing" | "similar_music" | "artist_discovery"
  seedTitle: text("seed_title"),
  seedArtist: text("seed_artist"),
  seedAlbum: text("seed_album"),
  spotifyTrackId: integer("spotify_track_id").references(() => spotifyTracks.id, { onDelete: "set null" }),
  spotifyUri: text("spotify_uri"),
  isrc: text("isrc"),
  coverUrl: text("cover_url"),
  spotifyPlaylistNames: text("spotify_playlist_names"), // JSON array
  popularity: integer("popularity"), // 0-100 Spotify global popularity
  status: text("status").notNull().default("pending"), // "pending" | "downloading" | "completed" | "dismissed"
  createdAt: text("created_at").default(sql`(datetime('now'))`),
});

export type SpotifyAuth = typeof spotifyAuth.$inferSelect;
export type SpotifySnapshot = typeof spotifySnapshots.$inferSelect;
export type SpotifyPlaylist = typeof spotifyPlaylists.$inferSelect;
export type SpotifyTrack = typeof spotifyTracks.$inferSelect;
export type WishListItem = typeof wishList.$inferSelect;

// ---------- Lidarr Integration ----------

export const lidarrConfig = sqliteTable("lidarr_config", {
  id: integer("id").primaryKey().default(1),
  url: text("url").notNull(),
  apiKey: text("api_key").notNull(),
  rootFolderPath: text("root_folder_path"),
  qualityProfileId: integer("quality_profile_id"),
  metadataProfileId: integer("metadata_profile_id"),
  lastTestedAt: text("last_tested_at"),
  lastTestResult: text("last_test_result"),
  updatedAt: text("updated_at").default(sql`(datetime('now'))`),
});

export type LidarrConfig = typeof lidarrConfig.$inferSelect;

// ---------- File Watcher ----------

export const watcherConfig = sqliteTable("watcher_config", {
  id: integer("id").primaryKey().default(1),
  enabled: integer("enabled", { mode: "boolean" }).default(false),
  watchPaths: text("watch_paths").notNull().default("[]"), // JSON array of strings
  debounceSeconds: integer("debounce_seconds").default(10),
  autoDeleteOnSuccess: integer("auto_delete_on_success", { mode: "boolean" }).default(true),
  updatedAt: text("updated_at").default(sql`(datetime('now'))`),
});

export type WatcherConfig = typeof watcherConfig.$inferSelect;
