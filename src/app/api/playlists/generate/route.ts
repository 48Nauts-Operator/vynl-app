import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/db";
import { playlists, playlistTracks, tracks, tasteProfile } from "@/lib/db/schema";
import { eq } from "drizzle-orm";
import { generatePlaylist, generateCoverArtPrompt, generateCoverArt } from "@/lib/ai";
import * as fs from "fs";
import * as path from "path";

export async function POST(request: NextRequest) {
  const { mood } = await request.json();

  if (!mood) {
    return NextResponse.json({ error: "Mood/activity required" }, { status: 400 });
  }

  const profiles = db.select().from(tasteProfile).all();
  const latest = profiles[profiles.length - 1];

  if (!latest) {
    return NextResponse.json(
      { error: "No taste profile. Complete discovery first." },
      { status: 400 }
    );
  }

  const availableTracks = db
    .select({
      id: tracks.id,
      title: tracks.title,
      artist: tracks.artist,
      genre: tracks.genre,
    })
    .from(tracks)
    .all();

  if (availableTracks.length === 0) {
    return NextResponse.json(
      { error: "No tracks in library. Scan your library first." },
      { status: 400 }
    );
  }

  try {
    const result = await generatePlaylist(
      latest.profileText,
      availableTracks.map((t) => ({
        id: t.id,
        title: t.title,
        artist: t.artist,
        genre: t.genre || undefined,
      })),
      mood
    );

    // Create the playlist
    const playlist = db
      .insert(playlists)
      .values({
        name: result.name,
        description: result.description,
        isAutoGenerated: true,
      })
      .returning()
      .get();

    // Add tracks
    const validTrackIds = result.trackIds.filter((id) =>
      availableTracks.some((t) => t.id === id)
    );

    for (let i = 0; i < validTrackIds.length; i++) {
      db.insert(playlistTracks)
        .values({
          playlistId: playlist.id,
          trackId: validTrackIds[i],
          position: i,
        })
        .run();
    }

    // Try to generate cover art
    let coverPath: string | null = null;
    try {
      const trackTitles = availableTracks
        .filter((t) => validTrackIds.includes(t.id))
        .map((t) => t.title);

      const artPrompt = await generateCoverArtPrompt(result.name, trackTitles, mood);
      const artUrl = await generateCoverArt(artPrompt);

      if (artUrl) {
        const response = await fetch(artUrl);
        const buffer = Buffer.from(await response.arrayBuffer());
        const coversDir = path.join(process.cwd(), "public", "covers");
        if (!fs.existsSync(coversDir)) fs.mkdirSync(coversDir, { recursive: true });

        const filename = `playlist-${playlist.id}.png`;
        fs.writeFileSync(path.join(coversDir, filename), buffer);
        coverPath = `/covers/${filename}`;

        db.update(playlists)
          .set({ coverPath })
          .where(eq(playlists.id, playlist.id))
          .run();
      }
    } catch (err) {
      console.error("Cover art generation failed (non-fatal):", err);
    }

    return NextResponse.json({ ...playlist, coverPath, trackCount: validTrackIds.length });
  } catch (err) {
    return NextResponse.json(
      { error: "Failed to generate playlist", details: String(err) },
      { status: 500 }
    );
  }
}
