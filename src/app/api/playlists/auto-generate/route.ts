import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { playlists, playlistTracks, tracks } from "@/lib/db/schema";
import { sql, eq, and } from "drizzle-orm";

export async function POST() {
  try {
    const fourWeeksAgo = new Date(Date.now() - 28 * 86400000).toISOString();

    // Find tracks with >= 3 plays in the last 4 weeks
    const heavyTracks = db.all(sql`
      SELECT
        h.track_id as trackId,
        COUNT(*) as playCount
      FROM listening_history h
      WHERE h.played_at >= ${fourWeeksAgo}
        AND h.track_id IS NOT NULL
      GROUP BY h.track_id
      HAVING COUNT(*) >= 3
      ORDER BY playCount DESC
      LIMIT 30
    `) as { trackId: number; playCount: number }[];

    if (heavyTracks.length === 0) {
      return NextResponse.json({ playlist: null, message: "Not enough play data" });
    }

    // Find or create the "Heavy Rotation" playlist
    let playlist = db
      .select()
      .from(playlists)
      .where(
        and(
          eq(playlists.name, "Heavy Rotation"),
          eq(playlists.isAutoGenerated, true)
        )
      )
      .get();

    if (!playlist) {
      const result = db
        .insert(playlists)
        .values({
          name: "Heavy Rotation",
          description: "Your most played tracks from the last 4 weeks",
          isAutoGenerated: true,
        })
        .returning()
        .get();
      playlist = result;
    }

    // Clear existing tracks
    db.delete(playlistTracks)
      .where(eq(playlistTracks.playlistId, playlist.id))
      .run();

    // Insert the heavy rotation tracks
    for (let i = 0; i < heavyTracks.length; i++) {
      db.insert(playlistTracks)
        .values({
          playlistId: playlist.id,
          trackId: heavyTracks[i].trackId,
          position: i + 1,
        })
        .run();
    }

    // Update playlist timestamp
    db.update(playlists)
      .set({ updatedAt: new Date().toISOString() })
      .where(eq(playlists.id, playlist.id))
      .run();

    // Fetch the full track data for the response
    const trackData = db.all(sql`
      SELECT
        t.id,
        t.title,
        t.artist,
        t.album,
        t.duration,
        t.file_path as filePath,
        t.cover_path as coverPath
      FROM playlist_tracks pt
      JOIN tracks t ON t.id = pt.track_id
      WHERE pt.playlist_id = ${playlist.id}
      ORDER BY pt.position
    `) as any[];

    return NextResponse.json({
      playlist: {
        id: playlist.id,
        name: playlist.name,
        trackCount: trackData.length,
        tracks: trackData.map((t) => ({
          id: t.id,
          title: t.title,
          artist: t.artist,
          album: t.album,
          duration: t.duration,
          filePath: t.filePath,
          coverPath: t.coverPath,
          source: "local",
        })),
      },
    });
  } catch (err) {
    console.error("Auto-generate error:", err);
    return NextResponse.json(
      { error: "Failed to generate playlist", details: String(err) },
      { status: 500 }
    );
  }
}
